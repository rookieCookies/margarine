extern {
    fn print_raw<T>(val: T, ty_id: int)
}


fn print<T>(val: T) {
    print_raw(val, type_id::<T>())
}


impl Range {
    fn __next__(self): Option<int> {
        if self.min < self.max {
            self.min += 1
            some(self.min-1)
        } else {
            none()
        }

    }
}


fn print_opt<T>(opt: Option<T>) {
    match opt {
        some => print("yay"),
        none => print("nay"),
    }
}


fn test<T, A>(val: T, boo: A) {
}


fn foo(val: int): int {
    too(val)
}

struct Foo {}


type any


extern {
    fn new_any<T>(value: T, type_id: int): any 
    fn downcast_any<T>(ptr: any, target: int): Option<T>
}



impl any {
    fn from<T>(value: T): any {
        new_any(value, type_id::<T>())
    }


    fn cast<T>(self): Option<T> {
        downcast_any::<T>(self, type_id::<T>())
    }
}


fn type_id_of<T>(val: T): int {
    type_id::<T>()
}


@startup
fn main() {
    print("hello")
    print(69.5)
    print(Foo {})
}
 
