extern {
    fn print_raw<T>(val: T, ty_id: int)
}


fn print<T>(val: T) {
    print_raw(val, type_id::<T>())
}


impl Range {
    fn __next__(self): Option<int> {
        if self.min < self.max {
            self.min += 1
            some(self.min-1)
        } else {
            none()
        }

    }
}


fn print_opt<T>(opt: Option<T>) {
    match opt {
        some => print("yay"),
        none => print("nay"),
    }
}


fn test<T, A>(val: T, boo: A) {
}


fn foo(val: int): int {
    too(val)
}

struct Foo {}


type any


extern {
    fn new_any<T>(value: T, type_id: int): any 
    fn downcast_any<T>(ptr: any, target: int): Option<T>
}



impl any {
    fn from<T>(value: T): any {
        new_any(value, type_id::<T>())
    }


    fn cast<T>(self): Option<T> {
        downcast_any::<T>(self, type_id::<T>())
    }
}



extern {
    fn push_list<T>(list: [T], value: T)
    fn pop_list<T>(list: [T]): Option<T>
    fn len_list<T>(list: [T]): int
}




impl<T> [T] {
    fn push(self, value: T) {
        push_list(self, value)
    }


    fn pop(self): Option<T> {
        pop_list(self)
    }


    fn len(self): int { len_list(self) }


    fn iter(self): ListIterator<T> {
        ListIterator {
            list: self,
            index: 0,
        }
    }

}


struct ListIterator<T> {
    list: [T],
    index: int,
}


impl<T> ListIterator<T> {
    fn __next__(self): Option<T> {
        if self.index < self.list.len() {
            self.index += 1
            some(self.list[self.index-1])
        } else {
            none()
        }
    }
}


impl [int] {
    fn hey(self) {
        print("hello")
    }
}


fn type_id_of<T>(val: T): int {
    type_id::<T>()
}


fn hey(): [int] {
}


struct A { b: B }
struct B { a: A }


@startup
fn main() {
    var foo = [69, 420]
    print(foo)
    foo[0] = 2
    foo.hey()

    foo.push(3)
    print(foo)
    print(foo.pop()!)
    
    for i in 0..10 {
        foo.push(i)
    }

    for i in foo.iter() {
        print(i)
    }
}
 
